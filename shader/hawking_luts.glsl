/**
 * @file hawking_luts.glsl
 * @brief Hawking Radiation LUT Sampling Utilities
 *
 * Phase 10.1: Hawking Radiation Thermal Glow
 *
 * Provides functions to sample precomputed LUTs for:
 * - Temperature T_H(M)
 * - Blackbody RGB spectrum
 *
 * LUTs generated by scripts/generate_hawking_lut.py
 * Data files: assets/luts/hawking_temp_lut.csv, hawking_spectrum_lut.csv
 *
 * Auto-generated: 2026-01-02
 */

#ifndef SHADER_HAWKING_LUTS_GLSL
#define SHADER_HAWKING_LUTS_GLSL

// Mathematical constants (local definitions to avoid include issues)
const float PI_LOCAL = 3.14159265358979323846;

// ============================================================================
// LUT Uniforms (loaded from CPU)
// ============================================================================

// Temperature LUT: T_H(M) mapping
// Format: 1D texture, 512 samples, log-spaced mass range
// uniform sampler2D hawkingTempLUT;  // Defined in main program

// Spectrum LUT: Temperature → RGB
// Format: 1D texture, 256 samples, log-spaced temperature range
// uniform sampler2D hawkingSpectrumLUT;  // Defined in main program

// LUT metadata (range information)
// uniform float hawkingMassMin;     // Minimum mass [g] (10^14)
// uniform float hawkingMassMax;     // Maximum mass [g] (10^42)
// uniform float hawkingTempMin;     // Minimum temperature [K] (10^3)
// uniform float hawkingTempMax;     // Maximum temperature [K] (10^12)

// ============================================================================
// Physical Constants (CGS units for Hawking calculations)
// ============================================================================

const float HBAR = 1.054571817e-27;  // Reduced Planck constant [erg·s]
const float C_LIGHT = 2.99792458e10; // Speed of light [cm/s]
const float G_GRAV = 6.67430e-8;     // Gravitational constant [cm³/g/s²]
const float K_BOLTZ = 1.380649e-16;  // Boltzmann constant [erg/K]

// LUT range (hardcoded from generation script)
const float HAWKING_LOG_MASS_MIN = 14.0;  // log10(mass_min) [log g]
const float HAWKING_LOG_MASS_MAX = 42.0;  // log10(mass_max) [log g]
const float HAWKING_LOG_TEMP_MIN = 3.0;   // log10(temp_min) [log K]
const float HAWKING_LOG_TEMP_MAX = 12.0;  // log10(temp_max) [log K]

// ============================================================================
// Direct Hawking Temperature Calculation (Fallback)
// ============================================================================

/**
 * @brief Compute Hawking temperature directly from formula.
 *
 * T_H = ℏc³ / (8πGMk_B)
 *
 * Used when LUT sampling is disabled or for validation.
 *
 * @param mass Black hole mass [g]
 * @return Hawking temperature [K]
 */
float hawkingTemperatureDirect(float mass) {
    if (mass <= 0.0) {
        return 1e30;  // Very large value (avoid inf in GLSL)
    }
    float c3 = C_LIGHT * C_LIGHT * C_LIGHT;
    return HBAR * c3 / (8.0 * PI_LOCAL * G_GRAV * mass * K_BOLTZ);
}

// ============================================================================
// LUT Sampling Functions
// ============================================================================

/**
 * @brief Sample Hawking temperature from LUT.
 *
 * Uses log-linear interpolation for accurate sampling across
 * many orders of magnitude.
 *
 * @param mass Black hole mass [g]
 * @param hawkingTempLUT Temperature LUT texture
 * @return Hawking temperature [K]
 */
float hawkingTemperatureLUT(float mass, sampler2D hawkingTempLUT) {
    if (mass <= 0.0) {
        return 1e30;
    }

    // Log-space interpolation
    float log_mass = log(mass) / log(10.0);  // log10(mass)

    // Clamp to LUT range
    log_mass = clamp(log_mass, HAWKING_LOG_MASS_MIN, HAWKING_LOG_MASS_MAX);

    // Normalize to [0,1] for texture sampling
    float u = (log_mass - HAWKING_LOG_MASS_MIN) /
              (HAWKING_LOG_MASS_MAX - HAWKING_LOG_MASS_MIN);

    // Sample LUT (y=0.5 for 1D texture stored as 2D)
    float temperature = texture(hawkingTempLUT, vec2(u, 0.5)).r;

    return temperature;
}

/**
 * @brief Sample blackbody RGB color from spectrum LUT.
 *
 * Uses log-linear interpolation in temperature space.
 *
 * @param temperature Hawking temperature [K]
 * @param spectrumLUT Spectrum LUT texture
 * @return RGB color (normalized to [0,1])
 */
vec3 sampleHawkingSpectrum(float temperature, sampler2D spectrumLUT) {
    if (temperature <= 0.0) {
        return vec3(0.0);
    }

    // Log-space interpolation
    float log_temp = log(temperature) / log(10.0);  // log10(T)

    // Clamp to LUT range
    log_temp = clamp(log_temp, HAWKING_LOG_TEMP_MIN, HAWKING_LOG_TEMP_MAX);

    // Normalize to [0,1] for texture sampling
    float u = (log_temp - HAWKING_LOG_TEMP_MIN) /
              (HAWKING_LOG_TEMP_MAX - HAWKING_LOG_TEMP_MIN);

    // Sample LUT (RGB stored in .rgb channels)
    vec3 rgb = texture(spectrumLUT, vec2(u, 0.5)).rgb;

    return rgb;
}

/**
 * @brief Compute Planck blackbody distribution directly (no LUT).
 *
 * B_λ(T) = (2hc²/λ⁵) / (exp(hc/λkT) - 1)
 *
 * RGB wavelengths: R=700nm, G=546nm, B=435nm
 *
 * @param temperature Hawking temperature [K]
 * @return RGB color (normalized to peak = 1.0)
 */
vec3 planckBlackbodyRGB(float temperature) {
    if (temperature <= 0.0) {
        return vec3(0.0);
    }

    // RGB wavelengths [cm]
    const vec3 wavelengths = vec3(700e-7, 546e-7, 435e-7);

    // Planck constant (not reduced)
    const float h = 2.0 * PI_LOCAL * HBAR;

    // Compute intensity for each channel
    vec3 intensities = vec3(0.0);
    for (int i = 0; i < 3; i++) {
        float lambda = wavelengths[i];

        // Exponent argument: hc/(λkT)
        float x = h * C_LIGHT / (lambda * K_BOLTZ * temperature);

        // Avoid overflow (exp(700) is too large)
        if (x > 700.0) {
            intensities[i] = 0.0;
        } else {
            // Planck distribution
            float lambda5 = lambda * lambda * lambda * lambda * lambda;
            float numerator = 2.0 * h * C_LIGHT * C_LIGHT / lambda5;
            float denominator = exp(x) - 1.0;
            intensities[i] = numerator / denominator;
        }
    }

    // Normalize to peak
    float peak = max(max(intensities.r, intensities.g), intensities.b);
    if (peak > 0.0) {
        intensities /= peak;
    }

    return intensities;
}

#endif // SHADER_HAWKING_LUTS_GLSL
