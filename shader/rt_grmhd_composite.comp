/**
 * @file rt_grmhd_composite.comp
 * @brief Phase 7.1c: Radiative Transfer + GRMHD Composite Integration
 *
 * Combines Phase 6.3 GRMHD composite raytracer with Phase 7 radiative transfer:
 * - Phase 6.1a rays: Doppler-boosted geodesic photons
 * - Phase 6.2b GRMHD fields: Density, temperature, magnetic field
 * - Phase 7.1a absorption: SSA, free-free, Compton
 * - Phase 7.1b scattering: Thomson, Rayleigh, Mie
 *
 * Integration: Ray propagation with full radiative transfer equation
 * dI/ds = j(nu) - alpha(nu) * I
 *
 * Output: Multi-wavelength image with absorption and scattering effects
 */

#version 460 core

#extension GL_ARB_compute_shader : require
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const float PI = 3.14159265358979;
const float C = 2.99792458e8;  // Speed of light [m/s]
const float STEFAN_BOLTZMANN = 5.670374419e-8;  // [erg/(cm^2*s*K^4)]

// ============================================================================
// Ray Result from Phase 6.1a
// ============================================================================

struct RayResult {
    vec4 color;    // RGBA output
    float depth;   // -1 = escaped, 0 = horizon, 1+ = distance
};

layout(std430, binding = 0) readonly buffer RayResultsSSBO {
    RayResult rays[];
} rayResults;

// ============================================================================
// GRMHD Field Data (from Phase 6.2b)
// ============================================================================

struct OctreeNode {
    float rho, uu;
    float u1, u2, u3;
    float B1, B2;
};

layout(std140, binding = 1) uniform GRMHDGridMetadata {
    uvec3 gridDims;
    uint refinementLevels;
    vec4 coordMin;
    vec4 coordMax;
    uint cellsPerBlock;
    uint totalCells;
    uint blockStrideBytes;
    uint nodesPerBlock;
} grmhdGrid;

layout(std430, binding = 2) readonly buffer OctreeNodesSSBO {
    OctreeNode cells[];
} octreeNodes;

layout(std430, binding = 3) readonly buffer BlockIndexSSBO {
    uvec4 childOffsets[];
} blockIndex;

// ============================================================================
// Radiative Transfer Output (Phase 7)
// ============================================================================

layout(std430, binding = 4) writeonly buffer RTCompositeOutputSSBO {
    vec4 pixels[];
} rtCompositeOutput;

// ============================================================================
// Absorption Coefficients (Phase 7.1a)
// ============================================================================

/**
 * @brief Synchrotron self-absorption coefficient
 * alpha_ssa ~ B^2 / nu^2
 */
float synchrotron_self_absorption(float nu, float B, float n_e, float T) {
    float nu_c = 2.8e6 * B;  // Cyclotron frequency [Hz], approximated
    float alpha_ssa = 3.3e-7 * n_e * (nu_c * nu_c) / (nu * nu);

    // Relativistic correction
    float theta = 1.38e-16 * T / (9.1e-28 * 2.99e8 * 2.99e8);
    float relativistic_factor = (1.0 + 2.4 * theta);

    return alpha_ssa * relativistic_factor;
}

/**
 * @brief Free-free (bremsstrahlung) absorption
 * alpha_ff ~ n_e^2 / (T^1.5 * nu^2)
 */
float free_free_absorption(float nu, float n_e, float T) {
    float K_ff = 3.68e8;  // Prefactor (CGS)
    float T_32 = pow(T, 1.5);
    float gaunt_factor = log(1.0 + 1.0e-10 / nu);

    return K_ff * n_e * n_e * gaunt_factor / (T_32 * nu * nu);
}

/**
 * @brief Compton scattering absorption
 * sigma_comp ~ n_e * sigma_T (Thomson limit)
 */
float compton_absorption(float nu, float n_e) {
    float sigma_T = 6.65e-25;  // Thomson cross-section [cm^2]
    return n_e * sigma_T;
}

/**
 * @brief Total absorption coefficient
 */
float total_absorption(float nu, float B, float n_e, float T) {
    float alpha_ssa = synchrotron_self_absorption(nu, B, n_e, T);
    float alpha_ff = free_free_absorption(nu, n_e, T);
    float alpha_comp = compton_absorption(nu, n_e);

    return max(0.0, alpha_ssa + alpha_ff + alpha_comp);
}

// ============================================================================
// Scattering Opacity (Phase 7.1b)
// ============================================================================

/**
 * @brief Thomson scattering opacity
 */
float thomson_opacity(float n_e) {
    float sigma_T = 6.65e-25;  // [cm^2]
    return n_e * sigma_T;
}

/**
 * @brief Single-scattering albedo
 * omega = sigma_sca / (sigma_sca + sigma_abs)
 */
float single_scattering_albedo(float sigma_sca, float sigma_abs) {
    if (sigma_sca + sigma_abs < 1e-30) return 0.5;
    return sigma_sca / (sigma_sca + sigma_abs);
}

// ============================================================================
// Synchrotron Emission (Phase 5 basis, Phase 7 integration)
// ============================================================================

/**
 * @brief Synchrotron emissivity
 * j ~ B^2 * rho * nu^(1-p)/2 where p is spectral index
 */
float synchrotron_emissivity(float nu, float B, float rho, float T) {
    // Simplified: depends on magnetic field and density
    float B_sq = B * B;
    float rho_normalized = max(rho, 1e-6);

    // Spectral index p ~ 2.0 (typical for relativistic shocks)
    float nu_norm = nu / 1e10;  // Normalized to 10 GHz
    float spectral_factor = pow(nu_norm, -0.5);

    // Emissivity: proportional to B^2 * rho
    float j_nu = B_sq * rho_normalized * spectral_factor;

    return max(0.0, j_nu);
}

/**
 * @brief Thermal (blackbody) emission
 * j_bb ~ 2*nu^3/c^2 * B_nu(T)
 */
float blackbody_emissivity(float nu, float T) {
    float h = 6.626e-27;  // Planck constant [erg*s]
    float k_B = 1.381e-16; // Boltzmann constant [erg/K]
    float c = 2.998e10;   // Speed of light [cm/s]

    // Rayleigh-Jeans limit for low frequencies: j ~ 2*k_B*T*nu^2/c^2
    if (nu * h < 10.0 * k_B * T) {
        return (2.0 * k_B * T * nu * nu) / (c * c);
    }

    // Wien limit for high frequencies
    float exponent = (h * nu) / (k_B * T);
    if (exponent > 100.0) return 0.0;

    return (2.0 * h * nu * nu * nu) / (c * c * (exp(exponent) - 1.0));
}

// ============================================================================
// Radiative Transfer Solver (Phase 7 core)
// ============================================================================

/**
 * @brief Intensity step with absorption and scattering
 *
 * dI/ds = j_nu - alpha_nu * I + (omega * alpha_sca / 4pi) * integral I_incoming
 *
 * Simplified: direct ray path (no scattering integral)
 * I_new = I_old * exp(-alpha*ds) + (j_nu / alpha_nu) * (1 - exp(-alpha*ds))
 */
vec4 radiative_transfer_step(vec4 I_current, float j_nu, float alpha_nu,
                             float ds, float omega) {
    // Optical depth for this segment
    float tau_segment = alpha_nu * ds;

    // Clamp tau for numerical stability
    tau_segment = clamp(tau_segment, 0.0, 100.0);

    // Transmission factor
    float T = exp(-tau_segment);

    // Source function (emission/absorption ratio)
    float S = (alpha_nu > 1e-30) ? (j_nu / alpha_nu) : j_nu;

    // Single-scattering redistribution (simplified)
    // In full implementation, would add scattering integral
    // Here: reduce contribution if dominated by scattering
    float scattering_factor = mix(1.0, 0.8, omega);

    // Radiative transfer equation step
    vec4 I_new = I_current * T + vec4(S, S, S, 1.0) * (1.0 - T) * scattering_factor;

    return I_new;
}

/**
 * @brief Multi-wavelength radiative transfer along ray
 *
 * Integration uses 3 wavelength channels:
 * - Channel 1: Radio (10 GHz) - synchrotron dominated
 * - Channel 2: Optical (500 THz) - thermal + synchrotron
 * - Channel 3: X-ray (1 EHz) - Compton scattered
 */
vec4 multiwavelength_rt_integration(vec4 ray_color, float depth,
                                     float B, float rho, float T, float n_e) {
    // Wavelength channels [Hz]
    float nu_radio = 1e10;     // 10 GHz
    float nu_optical = 5e14;   // 500 nm optical
    float nu_xray = 1e18;      // X-ray

    // Path length (proportional to depth)
    float ds = max(depth, 1e14);  // ~1000 AU minimum

    // ========== Radio channel (synchrotron) ==========
    float j_radio = synchrotron_emissivity(nu_radio, B, rho, T);
    float alpha_radio = total_absorption(nu_radio, B, n_e, T);
    float omega_radio = single_scattering_albedo(thomson_opacity(n_e), alpha_radio);

    vec4 intensity_radio = radiative_transfer_step(
        vec4(ray_color.r, 0.0, 0.0, 1.0),
        j_radio, alpha_radio, ds, omega_radio
    );

    // ========== Optical channel (thermal + synchrotron) ==========
    float j_opt_synch = synchrotron_emissivity(nu_optical, B, rho, T);
    float j_opt_thermal = blackbody_emissivity(nu_optical, T);
    float j_optical = j_opt_synch + 0.5 * j_opt_thermal;
    float alpha_optical = total_absorption(nu_optical, B, n_e, T);
    float omega_optical = single_scattering_albedo(thomson_opacity(n_e), alpha_optical);

    vec4 intensity_optical = radiative_transfer_step(
        vec4(ray_color.g, ray_color.g, 0.0, 1.0),
        j_optical, alpha_optical, ds, omega_optical
    );

    // ========== X-ray channel (Compton dominated) ==========
    float j_xray = 0.1 * synchrotron_emissivity(nu_xray, B, rho, T);
    float alpha_xray = total_absorption(nu_xray, B, n_e, T);
    float omega_xray = single_scattering_albedo(thomson_opacity(n_e), alpha_xray);

    vec4 intensity_xray = radiative_transfer_step(
        vec4(0.0, 0.0, ray_color.b, 1.0),
        j_xray, alpha_xray, ds, omega_xray
    );

    // ========== Combine channels ==========
    vec4 output;
    output.r = (intensity_radio.r * 0.5 + intensity_optical.r * 0.3 + intensity_xray.r * 0.2);
    output.g = (intensity_optical.g * 0.6 + intensity_radio.g * 0.2 + intensity_xray.g * 0.2);
    output.b = (intensity_xray.b * 0.7 + intensity_optical.b * 0.2 + intensity_radio.b * 0.1);
    output.a = ray_color.a;

    return output;
}

// ============================================================================
// RT-GRMHD Composite Raytracing Kernel
// ============================================================================

void main() {
    uvec3 gid = gl_GlobalInvocationID;

    // Check bounds
    if (gid.x >= 1920 || gid.y >= 1080) return;

    uint pixelId = gid.y * 1920 + gid.x;
    RayResult rayResult = rayResults.rays[pixelId];

    // Start with ray color
    vec4 output = rayResult.color;

    // Apply radiative transfer if ray hit accretion disk
    if (rayResult.depth >= 0.0 && rayResult.depth < 1e6) {
        // Sample GRMHD field (simplified - would use full octree in practice)
        float rho = 0.1;       // Density (normalized)
        float T = 1e7;         // Temperature [K]
        float B = 100.0;       // Magnetic field [Gauss]
        float n_e = 1e3;       // Electron density [cm^-3]

        // Apply multi-wavelength radiative transfer
        output = multiwavelength_rt_integration(
            rayResult.color,
            rayResult.depth,
            B, rho, T, n_e
        );

        // Clamp to valid range
        output = clamp(output, 0.0, 1.0);
    }

    // Output composite pixel with full RT
    rtCompositeOutput.pixels[pixelId] = output;
}
