/**
 * geodesic_trace.comp
 * Compute shader for parallel geodesic ray tracing.
 *
 * Uses RK4 integration for accurate null geodesic propagation
 * in curved spacetime (Schwarzschild or Kerr).
 *
 * GLSL 4.60 required for compute shaders.
 */

#version 460 core

// ============================================================================
// Work Group Configuration
// ============================================================================

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Output Image
// ============================================================================

layout(rgba32f, binding = 0) writeonly uniform image2D outputImage;

// ============================================================================
// Uniforms
// ============================================================================

uniform vec2 resolution;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPosition;

// Black hole parameters
uniform float schwarzschildRadius;
uniform float iscoRadius;
uniform float photonSphereRadius;
uniform float kerrSpin = 0.0;

// Integration parameters
uniform int maxSteps;
uniform float stepSize;
uniform float maxDistance;

// Feature toggles
uniform bool enableDisk;
uniform bool enableRedshift;

// ============================================================================
// Constants
// ============================================================================

const float PI = 3.14159265358979323846;
const float EPSILON = 1e-6;
const float C_LIGHT = 1.0; // Geometric units

// ============================================================================
// Structures
// ============================================================================

struct Ray {
    vec3 position;
    vec3 velocity;
    float affineParameter;
};

struct HitResult {
    bool hitDisk;
    bool hitHorizon;
    bool escaped;
    vec3 hitPoint;
    float phi;           // Azimuthal angle at hit
    float redshiftFactor;
};

struct KerrConsts {
    float E;
    float Lz;
    float Q;
};

struct KerrRay {
    float r;
    float theta;
    float phi;
    float t;
    float sign_r;
    float sign_theta;
};

// ============================================================================
// Kerr Helpers (Mino-time integration)
// ============================================================================

float kerrSigma(float r, float a, float cosTheta) {
    return r * r + a * a * cosTheta * cosTheta;
}

float kerrDelta(float r, float a, float r_s) {
    return r * r - r_s * r + a * a;
}

float kerrOuterHorizon(float r_s, float a) {
    float M = 0.5 * r_s;
    float disc = M * M - a * a;
    if (disc < 0.0) {
        return r_s;
    }
    return M + sqrt(disc);
}

vec3 kerrToCartesian(float r, float theta, float phi) {
    float sinTheta = sin(theta);
    return vec3(r * sinTheta * cos(phi),
                r * sinTheta * sin(phi),
                r * cos(theta));
}

KerrConsts kerrInitConsts(vec3 pos, vec3 dir) {
    KerrConsts c;
    c.E = 1.0;
    vec3 L = cross(pos, dir);
    c.Lz = L.z;
    float L2 = dot(L, L);
    c.Q = max(0.0, L2 - c.Lz * c.Lz);
    return c;
}

KerrRay kerrInitRay(vec3 pos, vec3 dir) {
    KerrRay ray;
    ray.r = length(pos);
    float invR = ray.r > EPSILON ? 1.0 / ray.r : 0.0;
    float cosTheta = clamp(pos.z * invR, -1.0, 1.0);
    ray.theta = acos(cosTheta);
    ray.phi = atan(pos.y, pos.x);
    ray.t = 0.0;

    vec3 e_r = normalize(pos);
    vec3 e_theta = normalize(vec3(cos(ray.theta) * cos(ray.phi),
                                  cos(ray.theta) * sin(ray.phi),
                                  -sin(ray.theta)));
    float dr = dot(dir, e_r);
    float dtheta = dot(dir, e_theta);
    ray.sign_r = dr >= 0.0 ? 1.0 : -1.0;
    ray.sign_theta = dtheta >= 0.0 ? 1.0 : -1.0;
    return ray;
}

void kerrStep(inout KerrRay ray, float r_s, float a, KerrConsts c, float dlam) {
    float r = ray.r;
    float theta = ray.theta;
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float sin2 = max(sinTheta * sinTheta, 1e-6);

    float Delta = kerrDelta(r, a, r_s);
    float A = (r * r + a * a) * c.E - a * c.Lz;
    float Lz_minus_aE = c.Lz - a * c.E;

    float R = A * A - Delta * (c.Q + Lz_minus_aE * Lz_minus_aE);
    float Theta = c.Q + (a * a * c.E * c.E * cosTheta * cosTheta) -
                  (c.Lz * c.Lz / sin2);

    if (R < 0.0) {
        ray.sign_r *= -1.0;
    }
    if (Theta < 0.0) {
        ray.sign_theta *= -1.0;
    }

    float sqrtR = sqrt(max(R, 0.0));
    float sqrtTheta = sqrt(max(Theta, 0.0));
    float deltaSafe = max(Delta, 1e-6);

    float dr_dlam = ray.sign_r * sqrtR;
    float dtheta_dlam = ray.sign_theta * sqrtTheta;
    float dphi_dlam = (c.Lz / sin2) - a * c.E + (a * A / deltaSafe);
    float dt_dlam = ((r * r + a * a) * A / deltaSafe) +
                    a * (c.Lz - a * c.E * sin2);

    ray.r += dlam * dr_dlam;
    ray.theta += dlam * dtheta_dlam;
    ray.phi += dlam * dphi_dlam;
    ray.t += dlam * dt_dlam;

    ray.theta = clamp(ray.theta, 1e-6, PI - 1e-6);
}

// ============================================================================
// Schwarzschild Geodesic Acceleration
// ============================================================================

/**
 * Compute geodesic acceleration in Schwarzschild spacetime.
 *
 * The null geodesic equation reduces to:
 * d²r/dλ² = -(r_s h²)/(2r⁴) + (3 r_s h²)/(2r⁵)
 *
 * In 3D Cartesian, using h² = |r × v|²:
 * a = -1.5 * r_s * h² * r / r⁵
 */
vec3 schwarzschildAccel(vec3 pos, vec3 vel, float r_s) {
    float r = length(pos);
    if (r < EPSILON) return vec3(0.0);

    vec3 h = cross(pos, vel);
    float h2 = dot(h, h);

    float r5 = r * r * r * r * r;

    return -1.5 * r_s * h2 * pos / r5;
}

// ============================================================================
// RK4 Integration Step
// ============================================================================

/**
 * Perform one RK4 integration step.
 */
void stepRK4(inout Ray ray, float r_s, float dt) {
    vec3 x0 = ray.position;
    vec3 v0 = ray.velocity;

    vec3 accel = schwarzschildAccel(x0, v0, r_s);

    // k1
    vec3 k1_x = v0;
    vec3 k1_v = accel;

    // k2
    vec3 x1 = x0 + 0.5 * dt * k1_x;
    vec3 v1 = v0 + 0.5 * dt * k1_v;
    accel = schwarzschildAccel(x1, v1, r_s);
    vec3 k2_x = v1;
    vec3 k2_v = accel;

    // k3
    vec3 x2 = x0 + 0.5 * dt * k2_x;
    vec3 v2 = v0 + 0.5 * dt * k2_v;
    accel = schwarzschildAccel(x2, v2, r_s);
    vec3 k3_x = v2;
    vec3 k3_v = accel;

    // k4
    vec3 x3 = x0 + dt * k3_x;
    vec3 v3 = v0 + dt * k3_v;
    accel = schwarzschildAccel(x3, v3, r_s);
    vec3 k4_x = v3;
    vec3 k4_v = accel;

    // Combine
    ray.position = x0 + (dt / 6.0) * (k1_x + 2.0 * k2_x + 2.0 * k3_x + k4_x);
    ray.velocity = v0 + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v);
    ray.affineParameter += dt;
}

// ============================================================================
// Disk Intersection
// ============================================================================

/**
 * Check for intersection with accretion disk (z = 0 plane).
 */
bool checkDiskIntersection(vec3 oldPos, vec3 newPos, float r_in, float r_out,
                           out vec3 hitPoint) {
    // Check if ray crossed z = 0
    if (oldPos.z * newPos.z > 0.0) {
        return false;
    }

    // Linear interpolation to find crossing point
    float t = -oldPos.z / (newPos.z - oldPos.z);
    hitPoint = mix(oldPos, newPos, t);

    float r = length(hitPoint.xy);
    return r >= r_in && r <= r_out;
}

// ============================================================================
// Gravitational Redshift
// ============================================================================

/**
 * Compute gravitational redshift factor.
 *
 * g = √(1 - r_s/r) for Schwarzschild
 */
float computeRedshiftFactor(vec3 pos, float r_s) {
    float r = length(pos);
    if (r <= r_s) return 0.0;

    if (abs(kerrSpin) > 1e-4) {
        float a = kerrSpin * 0.5 * r_s;
        float cosTheta = pos.z / max(r, EPSILON);
        float sigma = kerrSigma(r, a, cosTheta);
        float factor = 1.0 - (r_s * r) / sigma;
        if (factor <= 0.0) return 0.0;
        return sqrt(factor);
    }

    float factor = 1.0 - r_s / r;
    if (factor <= 0.0) return 0.0;
    return sqrt(factor);
}

// ============================================================================
// Main Ray Tracing
// ============================================================================

/**
 * Trace a single geodesic ray.
 */
HitResult traceGeodesic(Ray ray, float r_s) {
    HitResult result;
    result.hitDisk = false;
    result.hitHorizon = false;
    result.escaped = false;
    result.hitPoint = vec3(0.0);
    result.phi = 0.0;
    result.redshiftFactor = 1.0;

    float a = kerrSpin * 0.5 * r_s;
    float r_horizon = abs(kerrSpin) > 1e-4 ? kerrOuterHorizon(r_s, a) : r_s;

    // Disk parameters
    float r_disk_in = iscoRadius;
    float r_disk_out = 100.0 * r_s;

    vec3 oldPos;
    float dt = stepSize;

    bool useKerr = abs(kerrSpin) > 1e-4;
    KerrConsts kerrC;
    KerrRay kerrRay;
    if (useKerr) {
        kerrC = kerrInitConsts(ray.position, ray.velocity);
        kerrRay = kerrInitRay(ray.position, ray.velocity);
    }

    for (int step = 0; step < maxSteps; ++step) {
        oldPos = useKerr ? kerrToCartesian(kerrRay.r, kerrRay.theta, kerrRay.phi)
                         : ray.position;

        // Adaptive step size near horizon
        float r = useKerr ? kerrRay.r : length(ray.position);
        float adaptive_dt = dt * clamp(r / r_s - 1.0, 0.1, 1.0);

        if (useKerr) {
            kerrStep(kerrRay, r_s, a, kerrC, adaptive_dt);
            r = kerrRay.r;
        } else {
            stepRK4(ray, r_s, adaptive_dt);
            r = length(ray.position);
        }

        // Check horizon
        if (r < r_horizon * 1.01) {
            result.hitHorizon = true;
            result.hitPoint = useKerr ? kerrToCartesian(kerrRay.r, kerrRay.theta, kerrRay.phi)
                                      : ray.position;
            return result;
        }

        // Check disk intersection
        if (enableDisk) {
            vec3 diskHit;
            vec3 newPos = useKerr ? kerrToCartesian(kerrRay.r, kerrRay.theta, kerrRay.phi)
                                  : ray.position;
            if (checkDiskIntersection(oldPos, newPos, r_disk_in, r_disk_out, diskHit)) {
                result.hitDisk = true;
                result.hitPoint = diskHit;
                result.phi = atan(diskHit.y, diskHit.x);
                result.redshiftFactor = computeRedshiftFactor(diskHit, r_s);
                return result;
            }
        }

        // Check escape
        if (r > maxDistance) {
            result.escaped = true;
            result.hitPoint = useKerr ? kerrToCartesian(kerrRay.r, kerrRay.theta, kerrRay.phi)
                                      : ray.position;
            return result;
        }
    }

    // Max steps reached
    result.escaped = true;
    result.hitPoint = useKerr ? kerrToCartesian(kerrRay.r, kerrRay.theta, kerrRay.phi)
                              : ray.position;
    return result;
}

// ============================================================================
// Color Computation
// ============================================================================

/**
 * Compute color for horizon hit.
 */
vec4 horizonColor() {
    return vec4(0.0, 0.0, 0.0, 1.0);
}

/**
 * Compute color for disk hit.
 */
vec4 diskColorFromHit(HitResult hit, float r_s) {
    float r = length(hit.hitPoint.xy);

    // Temperature profile (simplified)
    float r_in = iscoRadius;
    float x = r_in / r;
    float flux = pow(x, 3.0) * (1.0 - sqrt(x));
    flux = max(0.0, flux);

    // Temperature to color
    float T_norm = pow(flux, 0.25);

    // Blackbody color approximation
    vec3 color;
    if (T_norm > 0.6) {
        color = vec3(1.0, 0.9, 0.8); // Hot: white-yellow
    } else if (T_norm > 0.3) {
        color = vec3(1.0, 0.6, 0.2); // Warm: orange
    } else {
        color = vec3(0.8, 0.2, 0.1); // Cool: red
    }

    // Apply intensity
    float intensity = flux * 2.0;

    // Doppler beaming
    float v = sqrt(0.5 * r_s / r);
    float cos_phi = cos(hit.phi);
    float doppler = 1.0 + 0.3 * v * cos_phi;
    intensity *= doppler * doppler * doppler;

    // Gravitational redshift
    if (enableRedshift) {
        float g = hit.redshiftFactor;
        float g3 = g * g * g;
        intensity *= g3;
        color = mix(color, vec3(1.0, 0.3, 0.1), 1.0 - g); // Shift to red
    }

    return vec4(color * intensity, 1.0);
}

/**
 * Compute color for escaped ray (background).
 */
vec4 backgroundColorFromDir(vec3 dir) {
    // Star field
    vec3 n = normalize(dir);
    float stars = pow(max(0.0, sin(n.x * 100.0) * sin(n.y * 100.0) * sin(n.z * 100.0)), 20.0);
    stars *= step(0.997, fract(sin(dot(n, vec3(12.9898, 78.233, 45.543))) * 43758.5453));

    vec3 color = vec3(0.01, 0.01, 0.02); // Dark background
    color += vec3(stars);

    return vec4(color, 1.0);
}

// ============================================================================
// Main Entry Point
// ============================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x >= int(resolution.x) || pixelCoord.y >= int(resolution.y)) {
        return;
    }

    // Compute normalized device coordinates
    vec2 uv = (vec2(pixelCoord) + 0.5) / resolution;
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.x *= resolution.x / resolution.y;

    // Ray direction in camera space
    vec3 rayDirCamera = normalize(vec3(ndc, -1.0));

    // Transform to world space
    mat3 viewRot = mat3(viewMatrix);
    vec3 rayDir = viewRot * rayDirCamera;

    // Initialize ray
    Ray ray;
    ray.position = cameraPosition;
    ray.velocity = rayDir;
    ray.affineParameter = 0.0;

    // Trace geodesic
    HitResult hit = traceGeodesic(ray, schwarzschildRadius);

    // Compute final color
    vec4 color;
    if (hit.hitHorizon) {
        color = horizonColor();
    } else if (hit.hitDisk) {
        color = diskColorFromHit(hit, schwarzschildRadius);
    } else {
        color = backgroundColorFromDir(normalize(hit.hitPoint - cameraPosition));
    }

    float depthDistance = length(hit.hitPoint - cameraPosition);
    float depthNormalized = clamp(depthDistance / maxDistance, 0.0, 1.0);
    color.a = depthNormalized;

    // Write to output image
    imageStore(outputImage, pixelCoord, color);
}
