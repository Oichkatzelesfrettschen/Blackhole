#version 460 core

/**
 * @file grmhd_raytracer_composite.comp
 * @brief Phase 6.3: Composite raytracer combining GPU geodesics with GRMHD fields
 *
 * Execution: Reads RK4-integrated rays from Phase 6.1a, samples GRMHD fields
 * via octree from Phase 6.2b, computes emitted radiation and outputs composite image
 *
 * Integration: Phase 6.1a rays + Phase 6.2b GRMHD octree -> image
 */

#extension GL_ARB_compute_shader : require
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const float PI = 3.14159265358979;
const float C = 2.99792458e8;  // Speed of light (m/s)

// ============================================================================
// Ray Result from Phase 6.1a
// ============================================================================

struct RayResult {
    vec4 color;    // RGBA output
    float depth;   // -1 = escaped, 0 = horizon, 1+ = distance
};

layout(std430, binding = 0) readonly buffer RayResultsSSBO {
    RayResult rays[];
} rayResults;

// ============================================================================
// GRMHD Field Data (from Phase 6.2b)
// ============================================================================

struct OctreeNode {
    float rho, uu;
    float u1, u2, u3;
    float B1, B2;
};

layout(std140, binding = 1) uniform GRMHDGridMetadata {
    uvec3 gridDims;
    uint refinementLevels;
    vec4 coordMin;
    vec4 coordMax;
    uint cellsPerBlock;
    uint totalCells;
    uint blockStrideBytes;
    uint nodesPerBlock;
} grmhdGrid;

layout(std430, binding = 2) readonly buffer OctreeNodesSSBO {
    OctreeNode cells[];
} octreeNodes;

layout(std430, binding = 3) readonly buffer BlockIndexSSBO {
    uvec4 childOffsets[];
} blockIndex;

// ============================================================================
// Composite Output (Phase 6.3)
// ============================================================================

layout(std430, binding = 4) writeonly buffer CompositeOutputSSBO {
    vec4 pixels[];
} compositeOutput;

// ============================================================================
// Synchrotron Emission Model
// ============================================================================

/**
 * SynchrotronFraction: ratio of synchrotron to total radiation
 * Depends on: B field strength, electron temperature, density
 */
float synchrotronFraction(float B_strength, float temp) {
    // Simplified: strong B -> high synchrotron
    return min(1.0, B_strength * B_strength / (temp + 1.0));
}

/**
 * PlasmaFrequency: electron plasma frequency
 * ωp = sqrt(n_e * e^2 / (m_e * ε0))
 */
float plasmaFrequency(float density) {
    // Simplified: f_p ~ sqrt(n_e)
    return sqrt(abs(density) + 0.1);
}

// ============================================================================
// GRMHD Sampling (placeholder for full octree integration)
// ============================================================================

vec4 sampleGRMHDField(vec3 coord) {
    // Placeholder: would call octree traversal
    // Returns (rho, uu, B_mag, T_eff)
    return vec4(0.1, 0.05, 1.0, 1e6);
}

// ============================================================================
// Composite Raytracing Kernel
// ============================================================================

void main() {
    uvec3 gid = gl_GlobalInvocationID;
    
    // Check bounds
    if (gid.x >= 1920 || gid.y >= 1080) return;
    
    uint pixelId = gid.y * 1920 + gid.x;
    RayResult rayResult = rayResults.rays[pixelId];
    
    // Phase 1: Ray result is base color
    vec4 output = rayResult.color;
    
    // Phase 2: If ray hit accretion disk (depth > 0), sample GRMHD
    if (rayResult.depth >= 0.0 && rayResult.depth < 1e6) {
        // Reconstruct world coordinate from ray (simplified)
        vec3 worldCoord = vec3(
            10.0 + rayResult.depth * 0.1,  // r
            1.57 + sin(pixelId) * 0.1,     // theta
            0.0 + cos(pixelId) * 0.1       // phi
        );
        
        // Sample GRMHD field
        vec4 grmhdField = sampleGRMHDField(worldCoord);
        
        // Compute synchrotron contribution
        float synchFrac = synchrotronFraction(grmhdField.z, grmhdField.w);
        
        // Blend: ray color (doppler-beamed photon) + synchrotron (local plasma)
        vec3 rayColor = rayResult.color.rgb;
        vec3 syncColor = vec3(synchFrac) * (grmhdField.x + 0.5);  // Density-weighted
        
        output.rgb = mix(rayColor, syncColor, 0.3);  // 30% synchrotron blend
        output.a = rayResult.color.a;
    }
    
    // Phase 3: Output composite pixel
    compositeOutput.pixels[pixelId] = output;
}
